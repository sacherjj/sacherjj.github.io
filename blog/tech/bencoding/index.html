<!DOCTYPE html>
<html lang="en" itemscope="itemscope" itemtype="http://schema.org/BlogPost">
<head>
    <meta charset="utf-8">
    <title>Bencoding (encoding of a .torrent file): joesacher.com</title>
    <meta itemprop="image" content="http://www.joesacher.com/images/favicon-128x128.png">
    <link rel="shortcut icon" href="http://www.joesacher.com/favicon.ico">
    <link rel="apple-touch-icon-precomposed" href="http://www.joesacher.com/images/apple-touch-icon.png">

    <meta name="description" itemprop="description" content="The Bencode format is an interesting design. It is byte based, which makes it safe from big-endian and little-endian translations. Somewhere when reading about how torrents worked, I got looking at their file format. As far as I know, the Bencode format isn’t used on anything but torrent files. The format is pretty simple, with only 4 different data structures: Byte String, Integer, List, and Dictionary. Bencode Basics Byte String This is formatted as [integer length]:[byte string]. Simply ..." />

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta name="copyright" content="Copyright (c) 1998-2015 Joe Sacher" />
    <meta name="author" content="Joe Sacher" />


    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]> <script src="http://www.joesacher.com/theme/js/html5.js"></script> <![endif]-->
    <!-- Le styles -->
    <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.no-icons.min.css" rel="stylesheet">
    <link rel="stylesheet" media="all" href="http://www.joesacher.com/theme/css/main.css">
    <link rel="stylesheet" media="all" href="http://www.joesacher.com/theme/css/final-%(versions)s.css">
    <link rel="stylesheet" media="all" href="http://www.joesacher.com/theme/css/pygments-monokai.css">
    <link rel="stylesheet" media="all" href="http://www.joesacher.com/theme/css/fontello.css">
    <link href='http://fonts.googleapis.com/css?family=Bitter:400,400italic|Droid+Serif:400' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Gabriela&amp;text=%26%C2%A7|PT+Mono' rel='stylesheet' type='text/css'>
    <meta property="twitter:account_id" content="22582024" />
    <meta name="twitter:card" content="summary">
    <meta name="twitter:image" content="http://www.joesacher.com/images/favicon-128x128.png">
    <meta name="twitter:site" content="@sacherjj">
    <meta name="twitter:title" content="Bencoding (encoding of a .torrent file)">
    <meta name="twitter:description" content="The Bencode format is an interesting design. It is byte based, which makes it safe from big-endian and little-endian translations. Somewhere when reading about how torrents worked, I got looking at their file format. As far as I know, the Bencode format isn’t used on anything but torrent files. The format is pretty simple, with only 4 different data structures: Byte String, Integer, List, and Dictionary. Bencode Basics Byte String This is formatted as [integer length]:[byte string]. Simply ...">
    <meta name="twitter:creator" content="@sacherjj">
    <meta name="twitter:domain" content="www.joesacher.com">
    <meta property="og:image" content="http://www.joesacher.com/images/favicon-128x128.png"/>
    <meta property="og:site_name" content="joesacher.com"/>
    <meta property="og:title" content="Bencoding (encoding of a .torrent file)"/>
    <meta property="og:type" content="article"/>
    <meta property="og:description" content="The Bencode format is an interesting design. It is byte based, which makes it safe from big-endian and little-endian translations. Somewhere when reading about how torrents worked, I got looking at their file format. As far as I know, the Bencode format isn’t used on anything but torrent files. The format is pretty simple, with only 4 different data structures: Byte String, Integer, List, and Dictionary. Bencode Basics Byte String This is formatted as [integer length]:[byte string]. Simply ..."/>
    <meta property="og:url" content="http://www.joesacher.com/blog/tech/bencoding/"/>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-3718160-3', 'auto');
  ga('send', 'pageview');
</script>
</head>

<body>
    <header class="blog-header hidden-print">
        <div class="container">
            <div class="row-fluid">
                <div class="span8"><a href="http://www.joesacher.com" class="brand">joesacher.com</a></div>
                <div class="span4" id="blog-nav">
                    <ul class="nav nav-pills pull-right">
                        <li >
                        <a href="http://www.joesacher.com/category/cooking.html ">cooking</a>
                        <li >
                        <a href="http://www.joesacher.com/category/how-to.html ">how-to</a>
                        <li >
                        <a href="http://www.joesacher.com/category/personal.html ">personal</a>
                        <li >
                        <a href="http://www.joesacher.com/category/reviews.html ">reviews</a>
                        <li  class="active" >
                        <a href="http://www.joesacher.com/category/tech.html ">tech</a>
                        <li >
                        <a href="http://www.joesacher.com/category/trans-am.html ">trans-am</a>
                    </ul>
                </div>
            </div>         </div>     </header>

    <div class="container">
        <div class="content">
            <div class="row-fluid">
                <div class="span11">
<article class="article">
    <div class="row-fluid">
        <div class="content-title span11">
            <h1 itemprop="name headline">Bencoding (encoding of a .torrent&nbsp;file)</h1>
        </div>
    </div>

    <div class="row-fluid">
        <aside class="article-sidebar span3">
<div class="row-fluid">
    <div class="span10">
        <p>
            <span itemprop="datePublished" class="hidden">2010-12-21T00:00:00-05:00</span>
            <span title="2010-12-21T00:00:00-05:00">Tue 21<span class="day_suffix">st</span> December, 2010</span><!-- <br /> by
            <span class="post-author vcard">
                <span class="fn" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person">
                    <span itemprop="name">Joe Sacher</span>
                </span>
            </span> -->
        </p>
        <p title="1312 words"><i class="muted icon-clock"></i>6 min read</p>
        <span itemprop="timeRequired" class="hidden">P6M</span>
        <span itemprop="wordCount" class="hidden">1312</span>

        <p>Category: <a href="http://www.joesacher.com/category/tech.html">tech</a></p>
    </div>

    <div class="span10">
        <p class="tag_heading">Tags:</p>
        <ul class="tag-list">
            <li class="tag"><i class="icon-tags muted"></i><a href="http://www.joesacher.com/tag/python.html">python</a></li>
        </ul>
    </div>

        <div class="span10 social_widgets">
            <br />
<a href="https://twitter.com/share" class="twitter-share-button" data-via="sacherjj" data-hashtags="python" data-url="http://www.joesacher.com/blog/tech/bencoding/" data-text="Bencoding (encoding of a .torrent file): joesacher.com">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
        </div>
</div>        </aside>

        <section class="content span9" itemprop="text articleBody">

            <p>The Bencode format is an interesting design.  It is byte based, which makes it safe from big-endian and little-endian translations.  Somewhere when reading about how torrents worked, I got looking at their file format.
As far as I know, the Bencode format isn’t used on anything but torrent files.  The format is pretty simple, with only 4 different data structures: Byte String, Integer, List, and Dictionary.</p>
<div class="section" id="bencode-basics">
<h2>Bencode Basics</h2>
<div class="section" id="byte-string">
<h3>Byte String</h3>
<p>This is formatted as [integer length]:[byte string].  Simply read the length number of bytes following the colon.</p>
</div>
<div class="section" id="integer">
<h3>Integer</h3>
<p>The integer type is structured as i[contents]e. Contents can be positive or negative integer, without leading zeros.</p>
<p>Valid examples: i-1234e i1234e</p>
</div>
<div class="section" id="list">
<h3>List</h3>
<p>The list type (or array if you like) is formatted as l[contents]e.  Contents will be any valid Bencode types just appended together.</p>
</div>
<div class="section" id="dictionary">
<h3>Dictionary</h3>
<p>The dictionary type (also know as a hash or an associative array) is formatted as d[contents]e.  Contents includes [key][value] pairs until termination.  The key value must always be a byte string, but the value may be any Bencode type (even another dictionary).</p>
</div>
</div>
<div class="section" id="the-code">
<h2>The Code</h2>
<p>It is possible to store complex structures with these simple types.  I enjoyed learning the format by creating a Python class for encoding and decoding data in Bencode format.
The source code for this class is available <a class="reference external" href="https://github.com/sacherjj/bencode">on my github</a>.</p>
<p>I have been using Python for quite a while as a scripting language, but only recently started trying to create proper classes and develop more advanced <span class="caps">OO</span> designed applications with Python.  I’m sure this isn’t purely Pythonic and would welcome any criticism and ways to improve.
I wanted to call out a few things in the code that were good learning experiences for me.</p>
<div class="section" id="encoding-methods">
<h3>Encoding Methods</h3>
<p>Functions are objects in Python and can be stored and referenced just like data.  In the internal encoding function _local_encode, I’m storing the various data type encode methods in a
dictonary with data type string as key.  This allows me to get data type string with <code>type(data).__name__</code>.  If the key exists in the dictonary, I envoke that method to process the data.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">_local_encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">""" Returns the proper Bencoded string for data given """</span>
    <span class="n">encoders</span> <span class="o">=</span> <span class="p">{</span><span class="s">'dict'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_dictionary</span><span class="p">,</span>
                <span class="s">'list'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_list</span><span class="p">,</span>
                <span class="s">'tuple'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_list</span><span class="p">,</span>
                <span class="s">'str'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_string</span><span class="p">,</span>
                <span class="s">'int'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_integer</span><span class="p">,</span>
                <span class="s">'float'</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_float</span><span class="p">}</span>
    <span class="n">data_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span>
    <span class="k">if</span> <span class="n">data_type</span> <span class="ow">in</span> <span class="n">encoders</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">encoders</span><span class="p">[</span><span class="n">data_type</span><span class="p">](</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">'Encoder is not defined for data type: </span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="n">data_type</span><span class="p">)</span>
</pre></div>
<p>String encoding is very simple, just joining length of the string with the data.</p>
<div class="highlight"><pre><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">_encode_string</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">""" Converts string to Bencoded Byte String """</span>
    <span class="k">return</span> <span class="s">'</span><span class="si">%d</span><span class="s">:</span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
<p>Encoding integer is just wrapping ‘i’ and ‘e’ around the string conversion of the integer.  Since bencode does not encode floats, those are converted to ints.</p>
<div class="highlight"><pre><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">_encode_integer</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">""" Converts Integer to Bencoded Integer string """</span>
    <span class="k">return</span> <span class="s">'i</span><span class="si">%d</span><span class="s">e'</span> <span class="o">%</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">_encode_float</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">""" Converts Float to Bencoded Integer string """</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_integer</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</pre></div>
<p>List encoding performs recursive calls into _local_encode as it loops through the list, just appending items.  I optimised with lists instead of string concatenation.  Originally, I built this with the ben variable as a string and += calls, which is terrible for memory performance.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">_encode_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">""" Converts List or Tuple to Bencoded List string """</span>
    <span class="n">ben</span> <span class="o">=</span> <span class="p">[</span><span class="s">'l'</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">ben</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_local_encode</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
    <span class="n">ben</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'e'</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ben</span><span class="p">)</span>
</pre></div>
<p>Dictionary works the same way as list, just appending the generated values from _local_encode with the addition of a string in front.  Again, this was changed from string concatenation to list append.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">_encode_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">""" Converts Dictionary to Bencoded Dictionary String """</span>
    <span class="n">ben</span> <span class="o">=</span> <span class="p">[</span><span class="s">'d'</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">ben</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_encode_string</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="n">ben</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_local_encode</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
    <span class="n">ben</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'e'</span><span class="p">)</span>
    <span class="k">return</span><span class="s">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ben</span><span class="p">)</span>
</pre></div>
<p>This came out simpler and cleaner than I expected for encoding.  But it is a really simple format, so it shouldn’t be too complex.</p>
</div>
<div class="section" id="decoding-methods">
<h3>Decoding Methods</h3>
<p>For my external decode method, I’m using a class level pointer for the bencoded string and walking through it.  I setup those two variables and call into _local_decode.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ben_string</span><span class="p">):</span>
    <span class="sd">""" Returns the data structure defined by the Bencoded string """</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ben_string</span> <span class="o">=</span> <span class="n">ben_string</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_decode</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Index Error at Pointer = </span><span class="si">%d</span><span class="s"> of </span><span class="si">%d</span><span class="se">\n</span><span class="si">%s</span><span class="s">"</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ben_string</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)))</span>
</pre></div>
<p>While I thought I might use the dictonary mapped methods again, I couldn’t find a clean way to handle the 11 possible cases for integer.  So, I decided to just just go old school flow control.  This is one situation that I would have used a switch statement with an else case if it was available in Python.  If you have a more Pythonic way of doing this, please ley me know!</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">_local_decode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">""" Detects and returns the proper Bencoded data type starting at current Pointer position """</span>
    <span class="n">cur_char</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ben_string</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cur_char</span> <span class="o">==</span> <span class="s">'i'</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_integer</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">cur_char</span> <span class="o">==</span> <span class="s">'l'</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_list</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">cur_char</span> <span class="o">==</span> <span class="s">'d'</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_dictionary</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">cur_char</span> <span class="ow">in</span> <span class="p">(</span><span class="s">'-'</span><span class="p">,</span> <span class="s">'0'</span><span class="p">,</span> <span class="s">'1'</span><span class="p">,</span> <span class="s">'2'</span><span class="p">,</span> <span class="s">'3'</span><span class="p">,</span> <span class="s">'4'</span><span class="p">,</span> <span class="s">'5'</span><span class="p">,</span> <span class="s">'6'</span><span class="p">,</span> <span class="s">'7'</span><span class="p">,</span> <span class="s">'8'</span><span class="p">,</span> <span class="s">'9'</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_byte_string</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">'Invalid character detected at position </span><span class="si">%d</span><span class="s"> : </span><span class="si">%s</span><span class="s">'</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">cur_char</span><span class="p">)))</span>
</pre></div>
<p>Before we get into Integer and String decoding, we have a helper function.  Both the Integer and the String will have a certain number of characters to parse into an integer.
The only difference is the stop character.  For the String, this is the length of the string with ‘:’ end character.  For the Integer, this is the actual data value with ‘e’ end character.
You will see this method called from both decode methods.  Note that the int() parsing handles the leading ‘-‘ fine for negative integers.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">_get_number</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end_char</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Returns number in string up to termination character given.</span>
<span class="sd">    """</span>

    <span class="n">start_pointer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span>
    <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ben_string</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span><span class="p">]</span> <span class="o">!=</span> <span class="n">end_char</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ben_string</span><span class="p">[</span><span class="n">start_pointer</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span><span class="p">])</span>  <span class="c"># Parse int</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c"># Consume the end_char</span>
    <span class="k">return</span> <span class="n">num</span>
</pre></div>
<p>The only job of the integer decode method is to consume the leading character that doesn’t exist in the string integer.  Then all the work is turned over to the _get_number method above up to the ‘e’ character.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">_parse_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Parses a Bencoded Integer type of format i&lt;number&gt;e</span>
<span class="sd">    """</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c"># Consume the 'i' start character</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_number</span><span class="p">(</span><span class="s">'e'</span><span class="p">)</span>
</pre></div>
<p>The String decoding gets the length integer this the helper function up to the ‘:’ character.  Then it gets the string for return, and increments the pointer past the string.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">_parse_byte_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Parses a Bencoded Byte String type of format &lt;len&gt;:&lt;byte string&gt;</span>
<span class="sd">    """</span>

    <span class="n">str_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_number</span><span class="p">(</span><span class="s">':'</span><span class="p">)</span>
    <span class="n">byte_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ben_string</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span> <span class="o">+</span> <span class="n">str_len</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span> <span class="o">+=</span> <span class="n">str_len</span>  <span class="c"># Consume the byte string</span>
    <span class="k">return</span> <span class="n">byte_string</span>
</pre></div>
<p>The list starts with ‘l’ and ends with ‘e’.  So we move the pointer to consume the ‘l’, then we loop until the current pointer character is an ‘e’.  Each time through the while,
the class level pointer might increment quite a bit, as data items are consumed.  However, we are not at the end of the list until we see a letter ‘e’.</p>
<p>For each list item, much like the recursive encoding, we call _local_decode to return us whatever the data is.</p>
<p>Since it is the responsibility of all the decoding methods to consume their bytes, we increment the pointer to move past the list termination ‘e’ at the end.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">_parse_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Parses a Bencoded List type of format l&lt;contents&gt;e</span>

<span class="sd">    All members of the list as simply appended together in Bencode format to make up &lt;contents&gt;</span>
<span class="sd">    """</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c"># Consume the 'l' start character</span>
    <span class="n">val</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ben_string</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'e'</span><span class="p">:</span>
        <span class="n">val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_local_decode</span><span class="p">())</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c"># Consume the 'e' termination character</span>
    <span class="k">return</span> <span class="n">val</span>
</pre></div>
<p>This is very similar to list processing, with the addition of the key.  We know that the key is required to be a byte string, so we call directly to that method.</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">_parse_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">"""    Parses a Bencoded Dictionary type of format d&lt;pairs&gt;e</span>

<span class="sd">    All pairs consist of ByteString key followed by any valid data type</span>
<span class="sd">    """</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c"># Consume the 'd' start character</span>
    <span class="n">be_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ben_string</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span><span class="p">]</span> <span class="o">!=</span> <span class="s">'e'</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_byte_string</span><span class="p">()</span>   <span class="c"># Skipping local decode, because key must be a byte string</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_local_decode</span><span class="p">()</span>
        <span class="n">be_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_pointer</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c"># Consume the 'e' termination character</span>
    <span class="k">return</span> <span class="n">be_dict</span>
</pre></div>
<p>If you have a cleaner implementation you would like to share, please contact me.  I found the few iterations on this to be enjoyable and a good learning experience.</p>
<p>The code is licensed under a <a class="reference external" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a></p>
</div>
</div>


            <hr />


            <!--
            <div class="row-fluid">
                <h3 id="article-comments-section">Comments</h3>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'joesachercom'; 

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            </div>
            -->
        </section>
    </div>

</article>
                </div>
            </div>         </div>     </div>

    <!--footer-->
    <footer class="blog-footer hidden-print">
        <div class="container">
            <div class="row-fluid">

                <div class="site-nav span2">
                    <h4 class="nav-header">Site</h4>
                    <ul class="nav nav-list" id="site-links">
                        <li><a href="http://www.joesacher.com"><i class="icon-home"></i>Home</a></li>
                        <li><a href="http://www.joesacher.com/blog/"><i class="icon-list"></i>Archives</a></li>
                        <li><a href="http://www.joesacher.com/tags.html"><i class="icon-tags"></i>Tags</a></li>
                    </ul>
                </div>

                <div class="social span2" id="socialist">
                    <h4 class="nav-header">LINKS</h4>
                    <ul class="nav nav-list">
                        <li><a href="http://www.linkedin.com/in/joesacher/" rel="author"><i class="icon-linkedin-squared"></i>LinkedIn</a></li>
                        <li><a href="http://stackoverflow.com/users/93191/joe" rel="author"><i class="icon-stackoverflow"></i>Stack&#8203;Overflow</a></li>

                    </ul>
                </div>

                <div class="links span2">
                    <h4 class="nav-header">&nbsp;</h4>
                    <ul class="nav nav-list">
                        <li><a href="http://twitter.com/sacherjj" rel="author"><i class="icon-twitter"></i>Twitter</a></li>
                        <li><a href="http://github.com/sacherjj" rel="author"><i class="icon-github-circled"></i>GitHub</a></li>
                    </ul>
                </div>

<div class="colophon span5" id="colophon">
  <h4 class="nav-header">About</h4>
  <p>I'm a Electrical Engineer by degree, Software Engineer by experience, and someone who loves to learn new things. I have a quick wit that it is often too corny. I'm good at thinking outside of the box, because I often don't realize one exists.</p>
</div>

            </div> <!--end of fluid row-->
            <hr />
            <p>
                <small>
                    &copy; 1998-2015 <a href="http://www.joesacher.com">Joe Sacher</a><br />
                </small>
            </p>
        </div> <!--end of blog-footer-->
    </footer> <!--end of container -->

    <!--/footer-->
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
    <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>

</body>
</html>